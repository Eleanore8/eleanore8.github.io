---
layout: default
title:  "前端路由"
date:   2020-03-12 17:50:00
des:  ""
motto:  ""
categories: js
---

### hash模式

使用到的API:

    window.location.hash = 'hash字符串'; // 用于设置 hash 值
    
    let hash = window.location.hash; // 获取当前 hash 值
    
    // 监听hash变化，点击浏览器的前进后退会触发
    window.addEventListener('hashchange', function(event){ 
        let newURL = event.newURL; // hash 改变后的新 url
        let oldURL = event.oldURL; // hash 改变前的旧 url
    },false)

#### 路由实现

1、创建路由对象, 实现 register 方法用于注册每个 hash 值对应的回调函数

2、不存在hash值时，认为是首页，所以实现 registerIndex 方法用于注册首页时的回调函数

3、通过 hashchange 监听 hash 变化，并定义 hash 变化时的回调函数

4、registerNotFound 方法，用于注册 hash 值未找到时的默认回调函数

5、try/catch 用于捕获异常，追加 registerError 方法，用于处理异常

    class HashRouter{
        constructor(){
            //用于存储不同hash值对应的回调函数
            this.routers = {};
            window.addEventListener('hashchange',this.load.bind(this),false)
        }
        //用于注册每个视图
        register(hash,callback = function(){}){
            this.routers[hash] = callback;
        }
        //用于注册首页
        registerIndex(callback = function(){}){
            this.routers['index'] = callback;
        }
        //用于处理视图未找到的情况
        registerNotFound(callback = function(){}){
            this.routers['404'] = callback;
        }
        //用于处理异常情况
        registerError(callback = function(){}){
            this.routers['error'] = callback;
        }
        //用于调用不同视图的回调函数
        load(){
            let hash = location.hash.slice(1),
                handler;
            //没有hash 默认为首页
            if(!hash){
                handler = this.routers.index;
            }
            //未找到对应hash值
            else if(!this.routers.hasOwnProperty(hash)){
                handler = this.routers['404'] || function(){};
            }
            else{
                handler = this.routers[hash]
            }
            //执行注册的回调函数
            try{
                handler.apply(this);
            }catch(e){
                console.error(e);
                (this.routers['error'] || function(){}).call(this,e);
            }
        }
    }

### history

早期的 history 中只能用于多页面的跳转：

    history.go(-1);       // 后退一页
    history.go(2);        // 前进两页
    history.forward(); // 等价于history.go(1); 前进一页
    history.back(); // 等价于history.go(-1); 后退一页

在 HTML5 的规范中，history 新增了以下几个 API：

    history.pushState(state, title, url); // 添加新的状态到历史状态栈
    history.replaceState(state, title, url); // 用新的状态代替当前状态
    history.state                // 返回当前状态对象

* state：合法的 Javascript 对象，可以用在 popstate 事件中

* title：现在大多浏览器忽略这个参数，可以直接用 null 代替

* url：任意有效的 URL，用于更新浏览器的地址栏

对于单页应用的 history 模式而言，url 的改变只能由下面四种方式引起：

1. 点击浏览器的前进或后退按钮

2. 点击 a 标签

3. 在 JS 代码中触发 history.pushState 函数

4. 在 JS 代码中触发 history.replaceState 函数

#### 路由实现

1. 创建一个路由对象, 实现 register 方法用于注册每个 location.pathname 值对应的回调函数

2. 当 location.pathname === '/' 时，认为是首页，所以实现 registerIndex 方法用于注册首页时的回调函数

3. location.path 没有对应的匹配，增加方法 registerNotFound 用于注册默认回调函数

4. 注册的回到函数执行时出现异常，增加方法 registerError 用于处理异常情况

5. 定义 assign 方法，用于通过 JS 触发 history.pushState 函数

6. 定义 replace 方法，用于通过 JS 触发 history.replaceState 函数

7. 监听 popstate 用于处理前进后退时调用对应的回调函数

8. 全局阻止A链接的默认事件，获取A链接的href属性，并调用 history.pushState 方法

9. 定义 load 方法，用于首次进入页面时 根据 location.pathname 调用对应的回调函数

    class HistoryRouter{
        constructor(){
            //用于存储不同path值对应的回调函数
            this.routers = {};
            this.listenPopState();
            this.listenLink();
        }
        //监听popstate
        listenPopState(){
            window.addEventListener('popstate',(e)=>{
                let state = e.state || {},
                    path = state.path || '';
                this.dealPathHandler(path)
            },false)
        }
        //全局监听A链接
        listenLink(){
            window.addEventListener('click',(e)=>{
                let dom = e.target;
                if(dom.tagName.toUpperCase() === 'A' && dom.getAttribute('href')){
                    e.preventDefault()
                    this.assign(dom.getAttribute('href'));
                }
            },false)
        }
        //用于首次进入页面时调用
        load(){
            let path = location.pathname;
            this.dealPathHandler(path)
        }
        //用于注册每个视图
        register(path,callback = function(){}){
            this.routers[path] = callback;
        }
        //用于注册首页
        registerIndex(callback = function(){}){
            this.routers['/'] = callback;
        }
        //用于处理视图未找到的情况
        registerNotFound(callback = function(){}){
            this.routers['404'] = callback;
        }
        //用于处理异常情况
        registerError(callback = function(){}){
            this.routers['error'] = callback;
        }
        //跳转到path
        assign(path){
            history.pushState({path},null,path);
            this.dealPathHandler(path)
        }
        //替换为path
        replace(path){
            history.replaceState({path},null,path);
            this.dealPathHandler(path)
        }
        //通用处理 path 调用回调函数
        dealPathHandler(path){
            let handler;
            //没有对应path
            if(!this.routers.hasOwnProperty(path)){
                handler = this.routers['404'] || function(){};
            }
            //有对应path
            else{
                handler = this.routers[path];
            }
            try{
                handler.call(this)
            }catch(e){
                console.error(e);
                (this.routers['error'] || function(){}).call(this,e);
            }
        }
    }


### 优缺点

hash优点：

* 兼容性更好，可以兼容到IE8

* 无需服务端配合处理非单页的url地址

缺点：

* 看起来更丑。

* 会导致锚点功能失效。

* 相同 hash 值不会触发动作将记录加入到历史栈中，而 pushState 则可以。


    
