---
layout: default
title:  "各种js小方法"
date:   2020-03-05 17:50:00
des:  ""
motto:  ""
categories: js
---

### 判断是否为数组

    Object.prototype.toString.call(arr) === '[object Array]';

### 不借助变量，交换两个数

针对的是Number，或者类型可以转换成数字的变量类型(会存在溢出的问题)

    function swap(a, b) {
       a = a + b;
       b = a - b;
       a = a - b;
    }

异或运算

    a ^= b;
    b ^= b; 
    a ^= b;

ES6的解构

    [a, b] = [b, a];
    
### 手写trim方法

    String.replace(/^\s+/,'').replace(/\s+$/,'')

### 将url参数解析为js对象

传统方法:

    function queryToObject(){
        const search = location.search.substr(1)
        const res = {}
        search.split('&').forEach(param => {
            const arr = param.split('=')
            res[arr[0]] = arr[1]
        })
        return res
    }

使用URLSearchParams：

    function queryToObject(){
        const res =t}
        const pList = new URLSearchParams(location.search)
        pList.forEach((val, key) =>{
            res [key] = val
        })
        return res
    }

### 函数去抖（debounce）

当调用函数n秒后，才会执行该动作，若在这n秒内又调用该函数则取消前一次并重新计算执行时间（频繁触发的情况下，只有足够的空闲时间，才执行代码一次）

    function debounce(delay, cb) {
        let timer
        return function () {
            if (timer) clearTimeout(timer)
            timer = setTimeout(function () {
                cb()
            }, delay)
        }
    }

### 函数节流（throttle）

函数节流的基本思想是函数预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期（一定时间内js方法只跑一次。比如人的眨眼睛，就是一定时间内眨一次）

    function throttle(cb, delay) {
        let startTime = Date.now()
        return function () {
            let currTime = Date.now()
            if (currTime - startTime > delay) {
                cb()
                startTime = currTime
            }
        }
    }

### 实现一个sleep函数

    function sleep(delay) {
        // 获取一个初始时间
        let startTime = new Date().getTime()
        // 如果时间差小于延迟时间，就一直循环
        while (new Date().getTime() - startTime < delay) {
            continue
        }
    }

### 写一个正则，根据name取cookie中的值

    function get(name){
      var reg = new RegExp(name+'=([^;]*)?(;|$)');
      var res = reg.exec(document.cookie);
      if(!res || !res[1])return '';
        try{
          if(/(%[0-9A-F]{2}){2,}/.test(res)){//utf8编码
          return decodeURIComponent(res);
        }else{//unicode编码
          return unescape(res);
        }
      }catch(e){
        return unescape(res);
      }
    }

### 数组去重

    let arr = [...new Set(..a)] // [1,2,3,4,5,6,7]

### flat

数组拍平方法 Array.prototype.flat() 也叫数组扁平化、数组拉平、数组降维。 

扩展运算符 + concat

    const arr = [1, 2, 3, 4, [1, 2, 3, [1, 2, 3, [1, 2, 3]]], 5, "string", { name: "弹铁蛋同学" }];
    // concat + 递归
    function flat(arr) {
      let arrResult = [];
      arr.forEach(item => {
        if (Array.isArray(item)) {
          arrResult = arrResult.concat(arguments.callee(item));   // 递归
          // 或者用扩展运算符
          // arrResult.push(...arguments.callee(item));
        } else {
          arrResult.push(item);
        }
      });
      return arrResult;
    }
    flat(arr)
    // [1, 2, 3, 4, 1, 2, 3, 1, 2, 3, 1, 2, 3, 5, "string", { name: "弹铁蛋同学" }];

reduce实现

    const arr = [1, 2, 3, 4, [1, 2, 3, [1, 2, 3, [1, 2, 3]]], 5, "string", { name: "弹铁蛋同学" }]
    
    // 首先使用 reduce 展开一层
    arr.reduce((pre, cur) => pre.concat(cur), []);
    // [1, 2, 3, 4, 1, 2, 3, [1, 2, 3, [1, 2, 3]], 5, "string", { name: "弹铁蛋同学" }];
    
    // 用 reduce 展开一层 + 递归
    const flat = arr => {
      return arr.reduce((pre, cur) => {
        return pre.concat(Array.isArray(cur) ? flat(cur) : cur);
      }, []);
    };
    // [1, 2, 3, 4, 1, 2, 3, 1, 2, 3, 1, 2, 3, 5, "string", { name: "弹铁蛋同学" }];


使用栈的思想

    // 栈思想
    function flat(arr) {
      const result = []; 
      const stack = [].concat(arr);  // 将数组元素拷贝至栈，直接赋值会改变原数组
      //如果栈不为空，则循环遍历
      while (stack.length !== 0) {
        const val = stack.pop(); 
        if (Array.isArray(val)) {
          stack.push(...val); //如果是数组再次入栈，并且展开了一层
        } else {
          result.unshift(val); //如果不是数组就将其取出来放入结果数组中
        }
      }
      return result;
    }
    const arr = [1, 2, 3, 4, [1, 2, 3, [1, 2, 3, [1, 2, 3]]], 5, "string", { name: "弹铁蛋同学" }]
    flat(arr)
    // [1, 2, 3, 4, 1, 2, 3, 1, 2, 3, 1, 2, 3, 5, "string", { name: "弹铁蛋同学" }];


通过传入整数参数控制“拉平”层数

    // reduce + 递归
    function flat(arr, num = 1) {
      return num > 0
        ? arr.reduce(
            (pre, cur) =>
              pre.concat(Array.isArray(cur) ? flat(cur, num - 1) : cur),
            []
          )
        : arr.slice();
    }
    const arr = [1, 2, 3, 4, [1, 2, 3, [1, 2, 3, [1, 2, 3]]], 5, "string", { name: "弹铁蛋同学" }]
    flat(arr, Infinity);
    // [1, 2, 3, 4, 1, 2, 3, 1, 2, 3, 1, 2, 3, 5, "string", { name: "弹铁蛋同学" }];


使用Generator实现

    function* flat(arr, num) {
      if (num === undefined) num = 1;
      for (const item of arr) {
        if (Array.isArray(item) && num > 0) {   // num > 0
          yield* flat(item, num - 1);
        } else {
          yield item;
        }
      }
    }
    const arr = [1, 2, 3, 4, [1, 2, 3, [1, 2, 3, [1, 2, 3]]], 5, "string", { name: "弹铁蛋同学" }]
    // 调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象。
    // 也就是遍历器对象（Iterator Object）。所以我们要用一次扩展运算符得到结果
    [...flat(arr, Infinity)]    
    // [1, 2, 3, 4, 1, 2, 3, 1, 2, 3, 1, 2, 3, 5, "string", { name: "弹铁蛋同学" }];


实现在原型链上重写 flat 函数

    Array.prototype.fakeFlat = function(num = 1) {
      if (!Number(num) || Number(num) < 0) {
        return this;
      }
      let arr = this.concat();    // 获得调用 fakeFlat 函数的数组
      while (num > 0) {           
        if (arr.some(x => Array.isArray(x))) {
          arr = [].concat.apply([], arr);	// 数组中还有数组元素的话并且 num > 0，继续展开一层数组 
        } else {
          break; // 数组中没有数组元素并且不管 num 是否依旧大于 0，停止循环。
        }
        num--;
      }
      return arr;
    };
    const arr = [1, 2, 3, 4, [1, 2, 3, [1, 2, 3, [1, 2, 3]]], 5, "string", { name: "弹铁蛋同学" }]
    arr.fakeFlat(Infinity)
    // [1, 2, 3, 4, 1, 2, 3, 1, 2, 3, 1, 2, 3, 5, "string", { name: "弹铁蛋同学" }];


考虑数组空位的情况

    // reduce + 递归
    Array.prototype.fakeFlat = function(num = 1) {
      if (!Number(num) || Number(num) < 0) {
        return this;
      }
      let arr = [].concat(this);
      return num > 0
        ? arr.reduce(
            (pre, cur) =>
              pre.concat(Array.isArray(cur) ? cur.fakeFlat(--num) : cur),
            []
          )
        : arr.slice();
    };
    const arr = [1, [3, 4], , ,];
    arr.fakeFlat()
    // [1, 3, 4]
    
    // foEach + 递归
    Array.prototype.fakeFlat = function(num = 1) {
      if (!Number(num) || Number(num) < 0) {
        return this;
      }
      let arr = [];
      this.forEach(item => {
        if (Array.isArray(item)) {
          arr = arr.concat(item.fakeFlat(--num));
        } else {
          arr.push(item);
        }
      });
      return arr;
    };
    const arr = [1, [3, 4], , ,];
    arr.fakeFlat()
    // [1, 3, 4]